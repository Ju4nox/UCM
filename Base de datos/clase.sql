CREATE TABLE JMRP_USUARIO(
    COD_USUARIO NUMBER,
    NOMBRE_USUARIO VARCHAR2(25),
    APELLIDO1_USUARIO VARCHAR2(25),
    APELLIDO2_USUARIO VARCHAR2(25),
    CONSTRAINT PK_JMRP_USUARIO PRIMARY KEY(COD_USUARIO)
);

--ESTRUCTURA DE UN PA
CREATE OR REPLACE PROCEDURE JMRP_CARGA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    INSERT INTO JMRP_USUARIO(COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO)
    VALUES(COD_USUARIO_P, NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P);
END;

BEGIN
    JMRP_CARGA_USUARIOS(1,'JUAN','ROJAS','PARADA');
    JMRP_CARGA_USUARIOS(2,'MACARENA','URBINA','FIGUEROA');
    JMRP_CARGA_USUARIOS(3,'MARCELA','PEREZ','BASTIAS');
END;

SELECT *
FROM JMRP_USUARIO;


-- TAREA 1 PROCEDIMIENTOS


--ESTRUCTURA DE UN PA
CREATE OR REPLACE PROCEDURE JMRP_ELIMINA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    COD_USUARIO_P NUMBER
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    DELETE FROM JMRP_USUARIO
    WHERE(COD_USUARIO = COD_USUARIO_P);
END;

BEGIN
    JMRP_ELIMINA_USUARIOS(1);
END;

SELECT *
FROM JMRP_USUARIO;

-- TAREA 2 PROCEDIMIENTOS


SELECT *
FROM JMRP_USUARIO;

--ESTRUCTURA DE UN PA
CREATE OR REPLACE PROCEDURE JMRP_MODIFICA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    COD_USUARIO_P NUMBER,
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    UPDATE JMRP_USUARIO SET
    NOMBRE_USUARIO = NOMBRE_USUARIO_P,
    APELLIDO1_USUARIO = APELLIDO1_USUARIO_P,
    APELLIDO2_USUARIO = APELLIDO2_USUARIO_P
    WHERE(COD_USUARIO = COD_USUARIO_P);
END;

BEGIN
    JMRP_MODIFICA_USUARIOS(1,'EDUARDO','CARRANZA','ROJAS');
END;

SELECT *
FROM JMRP_USUARIO;

-- TAREA 3

create or replace PROCEDURE JMRP_IUD_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    OPCION VARCHAR2,
    COD_USUARIO_P NUMBER,
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    LOCK TABLE JMRP_USUARIO IN ROW EXCLUSIVE MODE;
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    IF(UPPER(OPCION) = 'I') THEN
        
        INSERT INTO JMRP_USUARIO(COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO)
        VALUES(COD_USUARIO_P, NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P);

    ELSIF(UPPER(OPCION) = 'U') THEN

        UPDATE JMRP_USUARIO SET
        NOMBRE_USUARIO = NOMBRE_USUARIO_P,
        APELLIDO1_USUARIO = APELLIDO1_USUARIO_P,
        APELLIDO2_USUARIO = APELLIDO2_USUARIO_P
        WHERE(COD_USUARIO = COD_USUARIO_P);

    ELSIF(UPPER(OPCION) = 'D') THEN

        DELETE FROM JMRP_USUARIO
        WHERE(COD_USUARIO = COD_USUARIO_P);
    END IF;

    COMMIT;
        EXCEPTION
            WHEN STORAGE_ERROR THEN
            RAISE_APPLICATION_ERROR(-6500, 'Se acabó la memoria, o es corrupta');
            WHEN PROGRAM_ERROR THEN
			RAISE_APPLICATION_ERROR(-6501,'Error en la transacción, no se guardaron cambios');
            WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-1, 'El programa intentó insertar valores duplicados en una columna que está restringida por un índice único');
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20010,'Ocurrió un problema inesperado');
        ROLLBACK;
END;



BEGIN
    JMRP_IUD_USUARIOS('i',4, 'PABLO', 'ROMERO', 'CASTRO');
END;

BEGIN
    JMRP_IUD_USUARIOS('d',4,'PABLO', 'ROMERO', 'CASTRO');
END;

BEGIN
    JMRP_IUD_USUARIOS('u',4,'PEDRO', 'ROMERO', 'CASTRO');
END;


-- PRIMER DESAFIO =/
-- SE REQUIERE MODIFICAR LA TABLA USUARIO A TRAVÉS DE CÓDIGO CON LA 
-- INSTRUCCIÓN ALTER TABLE, AGREGANDO UN CAMPO NUEVO QUE SERÁ EMAIL 
-- DE TIPO VARCHAR2 DE LARGO 50.

ALTER TABLE JMRP_USUARIO
    ADD EMAIL VARCHAR2(50);

-- LUEGO CREARÁ UNA FUNCIÓN QUE SE ENCARGUE DE GENERAR LOS CORREOS 
-- ELECTRÓNICOS DE LA SIGUIENTE FORMA: PRIMERA Y SEGUNDA LETRA DEL 
-- NOMBRE, TERCERA Y CUARTA LETRA DEL PRIMER APELLIDO, SEGUIDO DE UN 
-- PUNTO Y EL SEGUNDO APELLIDO COMPLETO QUE TERMINE EN @TESTSQL.CL 

CREATE OR REPLACE FUNCTION JMRP_GENERA_CORREO(
    NOMBRE_USUARIO_F VARCHAR2,
    APELLIDO1_USUARIO_F VARCHAR2,
    APELLIDO2_USUARIO_F VARCHAR2
)
    RETURN VARCHAR2
IS
    EMAIL VARCHAR2(50);
BEGIN
    EMAIL := UPPER(CONCAT(SUBSTR(NOMBRE_USUARIO_F,1,2),CONCAT(SUBSTR(APELLIDO1_USUARIO_F,3,2),CONCAT('.',CONCAT(APELLIDO2_USUARIO_F,'@TESTSQL.CL')))));
    RETURN EMAIL;
END;

-- MODIFICAR SU PROCEDIMIENTO ALMACENADO DE CARGA DE DATOS, 
-- INCORPORANDO DENTRO DE LA CARGA DE DATOS EL CORREO 
-- LUEGO REALIZAR UN DELETE FROM A LA TABLA SIN 
-- RESTRICCIONES LIMPIARLA Y LUEGO UN LLAMADO AL PROCEDIMIENTO 
-- ALMACENADO PARA LA CARGA DE UN REGISTRO DONDE SE UTILICE LA 
-- FUNCIÓN.

CREATE SEQUENCE JMRP_PK_USUARIO
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 5
	NOCYCLE;



CREATE OR REPLACE PROCEDURE JMRP_CARGA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    LOCK TABLE JMRP_USUARIO IN ROW EXCLUSIVE MODE;
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    INSERT INTO JMRP_USUARIO(COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO,EMAIL)
    VALUES(JMRP_PK_USUARIO.NEXTVAL,NOMBRE_USUARIO_P,APELLIDO1_USUARIO_P,APELLIDO2_USUARIO_P,JMRP_GENERA_CORREO(NOMBRE_USUARIO_P,APELLIDO1_USUARIO_P,APELLIDO2_USUARIO_P));

        COMMIT;
        EXCEPTION
            WHEN STORAGE_ERROR THEN
            RAISE_APPLICATION_ERROR(-6500, 'Se acabó la memoria, o es corrupta');
            WHEN PROGRAM_ERROR THEN
			RAISE_APPLICATION_ERROR(-6501,'Error en la transacción, no se guardaron cambios');
            WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-1, 'El programa intentó insertar valores duplicados en una columna que está restringida por un índice único');
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20010,'Ocurrió un problema inesperado');
        ROLLBACK;
END;

SELECT *
FROM JMRP_USUARIO;

DELETE FROM JMRP_USUARIO;


BEGIN
    JMRP_CARGA_USUARIOS('Juan','Perez','Soto');
END;


SELECT *
FROM JMRP_USUARIO;

--- SEGUNDO DESAFÍO =)
-- CREAR UNA FUNCIÓN QUE SE ENCARGUE DE REALIZAR LA CARGA DE REGISTROS 
-- PARA LAS CLAVES PRIMARIAS DE CARACTER AUTOINCREMENTAL.
CREATE OR REPLACE FUNCTION JMRP_CARGA_REGISTROS(
)
    RETURN NUMBER
IS
    CLAVE NUMBER :=0;
BEGIN
    SELECT MAX(COD_USUARIO)+1 INTO CLAVE
    FROM JMRP_USUARIO;
    IF(CLAVE IS NULL) THEN
        CLAVE :=1;
    END IF;
    RETURN CLAVE;
END;
-- LUEGO MODIFICAR SU PROCEDIMIENTO ALMACENADO DE CARGA DE DATOS, 
-- INCORPORANDO DENTRO DE LA CARGA DE DATOS EL LLAMADO A LA 
-- FUNCIÓN QUE SE ENCARGUE DEL CAMPO PRIMARIO.
CREATE OR REPLACE PROCEDURE JMRP_CARGA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    LOCK TABLE JMRP_USUARIO IN ROW EXCLUSIVE MODE;
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    INSERT INTO JMRP_USUARIO(COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO,EMAIL)
    VALUES(JMRP_CARGA_REGISTROS,NOMBRE_USUARIO_P,APELLIDO1_USUARIO_P,APELLIDO2_USUARIO_P,JMRP_GENERA_CORREO(NOMBRE_USUARIO_P,APELLIDO1_USUARIO_P,APELLIDO2_USUARIO_P));

        COMMIT;
        EXCEPTION
            WHEN STORAGE_ERROR THEN
            RAISE_APPLICATION_ERROR(-6500, 'Se acabó la memoria, o es corrupta');
            WHEN PROGRAM_ERROR THEN
			RAISE_APPLICATION_ERROR(-6501,'Error en la transacción, no se guardaron cambios');
            WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-1, 'El programa intentó insertar valores duplicados en una columna que está restringida por un índice único');
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20010,'Ocurrió un problema inesperado');
        ROLLBACK;
END;

-- REALIZAR UN DELETE FROM A LA TABLA SIN RESTRICCIONES LIMPIARLA
-- Y LUEGO UN LLAMADO AL PROCEDIMIENTO ALMACENADO PARA LA CARGA 
-- DE 10 REGISTROS
BEGIN
    JMRP_CARGA_USUARIOS('JUAN','PEREZ','SOTO');
    JMRP_CARGA_USUARIOS('MARIA','LOPEZ','GARCIA');
    JMRP_CARGA_USUARIOS('CARLOS','ROJAS','RAMIREZ');
    JMRP_CARGA_USUARIOS('ANA','HERRERA','TORO');
    JMRP_CARGA_USUARIOS('PEDRO','MUNOZ','CASTILLO');
    JMRP_CARGA_USUARIOS('LUISA','GOMEZ','DIAZ');
    JMRP_CARGA_USUARIOS('ANDRES','FUENTES','NAVARRO');
    JMRP_CARGA_USUARIOS('SOFIA','TORRES','MORALES');
    JMRP_CARGA_USUARIOS('RICARDO','VERA','PARRA');
    JMRP_CARGA_USUARIOS('CAMILA','SALAZAR','REYES');
END;

SELECT * FROM JMRP_USUARIO;


-- TAREA 1
-- SE SOLICITA QUE GENERE UN TRIGGER QUE SE ENCARGUE DE OTORGAR LA CLAVE 
-- PRIMARIA PARA LA TABLA DETALLE DE NOTAS Y OTRO PARA LA TABLA USUARIOS
-- TRABAJADA EN CLASES ANTERIORES.
-- COMO TAMBIÉN GENERAR OTRO TRIGGER QUE SE ENCARGUE DE TRABAJAR LOS 
-- CAMPOS DE TIPO TEXTO EVALUÁNDOLOS EN MAYÚSCULA PARA LA TABLA USUARIOS.

CREATE OR REPLACE TRIGGER JMRP_PK_DETALLE_NOTAS
BEFORE INSERT
ON JMRP_DETALLE_NOTAS
FOR EACH ROW
BEGIN
    SELECT MAX(NRO_DETALLE) + 1 INTO :NEW.NRO_DETALLE
    FROM JMRP_DETALLE_NOTAS;
    IF(:NEW.NRO_DETALLE IS NULL) THEN
    :NEW.NRO_DETALLE :=1;
    END IF;
END;

SELECT *
FROM JMRP_DETALLE_NOTAS;

INSERT INTO JMRP_DETALLE_NOTAS(NOTA1,NOTA2,NOTA3)
VALUES(5,4,3);


-- TRIGGER TABLA USUARIOS
-- FUNCIONA PERO SE PUEDE MEJORAR, MANDANDO PARA LA GENERACION DE CORREOS QUIZÁS
CREATE OR REPLACE TRIGGER JMRP_PK_USUARIOS
BEFORE INSERT
ON JMRP_USUARIO
FOR EACH RROW
BEGIN
    SELECT MAX(COD_USUARIO) + 1 INTO :NEW.COD_USUARIO
    FROM JMRP_USUARIO;
    IF(:NEW.COD_USUARIO IS NULL) THEN
    :NEW.COD_USUARIO :=1;
    END IF;
END;

-- TRIGGER CAMPOS TIPO TEXTO

CREATE OR REPLACE TRIGGER JMRP_TEXT_TEST
BEFORE INSERT
ON JMRP_USUARIO
FOR EACH ROW
BEGIN
    :NEW.NOMBRE_USUARIO := UPPER(:NEW.NOMBRE_USUARIO);
    :NEW.APELLIDO1_USUARIO := UPPER(:NEW.APELLIDO1_USUARIO);
    :NEW.APELLIDO2_USUARIO := UPPER(:NEW.APELLIDO2_USUARIO);
    :NEW.EMAIL_USUARIO := UPPER(:NEW.EMAIL_USUARIO);
END;

SELECT *
FROM JMRP_DETALLE_NOTAS;

INSERT INTO JMRP_USUARIO(NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO)
VALUES('macarena','urbina','figueroa');

-- CARGA DE DATOS MODIFICADA

CREATE OR REPLACE PROCEDURE JMRP_CARGA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    INSERT INTO JMRP_USUARIO(NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO)
    VALUES(NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P);
END;

SELECT *
FROM JMRP_USUARIO;


BEGIN
    JMRP_CARGA_USUARIOS('JUAN','ROJAS','PARADA');
END;
-- 
-- 
-- 
-- 

create or replace FUNCTION JMRP_GENERA_CORREO(
    NOMBRE_F IN VARCHAR2,
    APELLIDO1_F IN VARCHAR2,
    APELLIDO2_F IN VARCHAR2
)
RETURN VARCHAR2
IS
    APELLIDO1_AUX VARCHAR2(50);
    EMAIL VARCHAR2(50);
    EMP_DUPLICADOS NUMBER := 0;
    EMAIL_F VARCHAR2(50);
BEGIN
    APELLIDO1_AUX := SUBSTR(APELLIDO1_F, 1, 4);
    EMAIL := CONCAT(APELLIDO1_AUX, CONCAT('.', APELLIDO2_F));

    SELECT COUNT(COD_USUARIO) INTO EMP_DUPLICADOS
    FROM JMRP_USUARIO
    WHERE (NOMBRE_USUARIO = UPPER(NOMBRE_F))
      AND (APELLIDO1_USUARIO = UPPER(APELLIDO1_F))
      AND (APELLIDO2_USUARIO = UPPER(APELLIDO2_F));

    IF EMP_DUPLICADOS = 0 THEN
        EMAIL_F := CONCAT(EMAIL, '@TESTSQL.CL');
    ELSE
        EMAIL_F := CONCAT(EMAIL, CONCAT(EMP_DUPLICADOS, '@TESTSQL.CL'));
    END IF;

    RETURN EMAIL_F;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'Ups, algo falló...';
END;


CREATE OR REPLACE PROCEDURE JMRP_CARGA_USUARIOS(
    --PARAMETROS QUE RECIBIRA EL PROCEDIMIENTO SEPARADO POR COMAS
    NOMBRE_USUARIO_P VARCHAR2,
    APELLIDO1_USUARIO_P VARCHAR2,
    APELLIDO2_USUARIO_P VARCHAR2
)
IS
-- SI REQUIRE VARIABLES LOCALES, VAN ACÁ, SI NO, SE OBVIA
BEGIN
    LOCK TABLE JMRP_USUARIO IN ROW EXCLUSIVE MODE;
    -- CUERPO DEL PROCEDIMIENTO (ACCIONES)
    INSERT INTO JMRP_USUARIO(NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO,EMAIL)
    VALUES(NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P,JMRP_GENERA_CORREO(NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P));
    COMMIT;
        EXCEPTION
            WHEN STORAGE_ERROR THEN
            RAISE_APPLICATION_ERROR(-6500, 'Se acabó la memoria, o es corrupta');
            WHEN PROGRAM_ERROR THEN
			RAISE_APPLICATION_ERROR(-6501,'Error en la transacción, no se guardaron cambios');
            WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-1, 'El programa intentó insertar valores duplicados en una columna que está restringida por un índice único');
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20010,'Ocurrió un problema inesperado');
        ROLLBACK;
END;

-- CREACION DE LA TABLA
CREATE TABLE JMRP_SALARY_AUDIT(
    AUDIT_ID NUMBER,
    EMPLOYEE_ID NUMBER,
    OLD_SALARY NUMBER,
    NEW_SALARY NUMBER,
    CHANGE_DATE DATE,
    CHANGED_BY VARCHAR2(100)

    CONSTRAINT JMRP_PK_SALARY_AUDIT PRIMARY KEY(AUDIT_ID);
);

-- CREACION SECUENCIA

CREATE SEQUENCE JMRP_SALARY_AUDIT_SEQ
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 5
    NOCYCLE;

-- CREACION PROCEDIMIENTO

CREATE OR REPLACE PROCEDURE JMRP_SP_GIVE_RAISE(
    P_EMPLOYEE_ID NUMBER,
    P_RAISE_PERCENTAGE NUMBER
)
IS
BEGIN
    LOCK TABLE JMRP_SALARY_AUDIT IN ROW EXCLUSIVE MODE;

    UPDATE JMRP_SALARY_AUDIT SET
    EMPLOYEE_ID = P_EMPLOYEE_ID
    NEW_SALARY := ((OLD_SALARY * P_RAISE_PERCENTAGE)/100) + OLD_SALARY;
    COMMIT;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(+100, 'NO SE ENCONTRARON LOS DATOS PAJARÓN');
END;


-- RESOLUCIÓN PRUEBA
-- 1) CREAR TRIGGERS QUE SE ENCARGUEN DE GENERAR LA CLAVE PRIMARIA, DE CARÁCTER AUTOINCREMENTAL PARA LAS TABLAS PRODUCTO Y LOG_VENTA

-- CREACION TABLAS

CREATE TABLE JMRP_PRODUCTO(
    ID_PRODUCTO NUMBER,
    TIPO_PRODUCTO VARCHAR2(30),

    CONSTRAINT PK_JMRP_ID_PRODUCTO PRIMARY KEY(ID_PRODUCTO)
);

CREATE TABLE JMRP_LOG_VENTA(
    ID_PRODUCTO NUMBER,
    DATE_VENTA DATE,

    CONSTRAINT PK_JMRP_IDF_PRODUCTO PRIMARY KEY(ID_PRODUCTO)
    CONSTRAINT FK_JMRP_ID_PRODUCTO FOREIGN KEY(ID_PRODUCTO) REFERENCES JMRP_PRODUCTO(ID_PRODUCTO)
);

-- CREACION TRIGGERS

CREATE OR REPLACE TRIGGER JMRP_PRODUCTO
BEFORE INSERT
ON JMRP_PRODUCTO
FOR EACH ROW
BEGIN
    SELECT MAX(ID_PRODUCTO) + 1 INTO :NEW.ID_PRODUCTO
    FROM JMRP_USUARIO;
    IF(:NEW.ID_PRODUCTO IS NULL) THEN
    :NEW.ID_PRODUCTO :=1;
    END IF;
END;

CREATE OR REPLACE TRIGGER JMRP_LOG_VENTA
BEFORE INSERT
ON JMRP_PRODUCTO
FOR EACH ROW
BEGIN
    SELECT MAX(ID_PRODUCTO) + 1 INTO :NEW.ID_PRODUCTO
    FROM JMRP_USUARIO;
    IF(:NEW.ID_PRODUCTO IS NULL) THEN
    :NEW.ID_PRODUCTO :=1;
    END IF;
END;

CREATE OR REPLACE TRIGGER JMRP_SAPO
BEFORE UPDATE
ON JMRP_PRODUCTO
FOR EACH ROW
BEGIN
    SELECT 'EL PRECIO ANTIGUO FUE: ' || :OLD.PRECIO, 'EL NUEVO PRECIO ES: ' || :NEW.PRECIO
    FROM JMRP_PRODUCTO
END;

CREATE OR REPLACE FUNCTION JMRP_USTOCK(

)
RETURN NUMBER
IS
BEGIN

END;